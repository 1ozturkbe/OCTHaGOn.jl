var documenterSearchIndex = {"docs":
[{"location":"api/iai_wrappers.html#IAI-wrappers","page":"IAI wrappers","title":"IAI wrappers","text":"","category":"section"},{"location":"api/iai_wrappers.html","page":"IAI wrappers","title":"IAI wrappers","text":"Work in progress...","category":"page"},{"location":"api/iai_wrappers.html","page":"IAI wrappers","title":"IAI wrappers","text":"find_leaves\r\npwl_constraint_data\r\ntrust_region_data\r\ncheck_if_trained","category":"page"},{"location":"api/iai_wrappers.html#Main.OCTHaGOn.find_leaves","page":"IAI wrappers","title":"Main.OCTHaGOn.find_leaves","text":"find_leaves(lnr::OptimalTreeLearner)\n\nFinds all leaves of OptimalTreeLearner.\n\n\n\n\n\n","category":"function"},{"location":"api/iai_wrappers.html#Main.OCTHaGOn.pwl_constraint_data","page":"IAI wrappers","title":"Main.OCTHaGOn.pwl_constraint_data","text":"pwl_constraint_data(lnr::IAI.OptimalTreeLearner, vks)\n\nCreates PWL dataset from a OptimalTreeLearner Arguments:     lnr: OptimalTreeLearner     vks: headers of DataFrame X, i.e. varkeys Returns:     Dict[leaf_number] containing [B0, B]\n\n\n\n\n\n","category":"function"},{"location":"api/iai_wrappers.html#Main.OCTHaGOn.trust_region_data","page":"IAI wrappers","title":"Main.OCTHaGOn.trust_region_data","text":"trust_region_data(lnr:: IAI.OptimalTreeLearner, vks)\n\nCreates trust region from a OptimalTreeLearner Arguments:     lnr: OptimalTreeLearner     vks: headers of DataFrame X, i.e. varkeys Returns:     Dict[leaf_number] containing [B0, B]\n\n\n\n\n\n","category":"function"},{"location":"api/iai_wrappers.html#Main.OCTHaGOn.check_if_trained","page":"IAI wrappers","title":"Main.OCTHaGOn.check_if_trained","text":"Checks if a learner is trained. \n\n\n\n\n\n","category":"function"},{"location":"api/datastructures.html#Data-structures","page":"Data structures","title":"Data structures","text":"","category":"section"},{"location":"api/datastructures.html","page":"Data structures","title":"Data structures","text":"Work in progress...","category":"page"},{"location":"api/datastructures.html","page":"Data structures","title":"Data structures","text":"GlobalModel\r\nBlackBoxLearner\r\nBlackBoxClassifier\r\nBlackBoxRegressor\r\nLinkedLearner\r\nLinkedClassifier\r\nLinkedRegressor","category":"page"},{"location":"api/datastructures.html#Main.OCTHaGOn.GlobalModel","page":"Data structures","title":"Main.OCTHaGOn.GlobalModel","text":"Contains all constraints and data to solve the global optimization optimization problem. Add linear constraints to a GlobalModel through JuMP.@constraint, and nonlinear constraints using add_nonlinear_constraint.\n\n\n\n\n\n","category":"type"},{"location":"api/datastructures.html#Main.OCTHaGOn.BlackBoxLearner","page":"Data structures","title":"Main.OCTHaGOn.BlackBoxLearner","text":"BBL type is for function definitions! \n\n\n\n\n\n","category":"type"},{"location":"api/datastructures.html#Main.OCTHaGOn.BlackBoxClassifier","page":"Data structures","title":"Main.OCTHaGOn.BlackBoxClassifier","text":"@with_kw mutable struct BlackBoxClassifier\n\nAllows for approximation of constraints using OCTs. To be added to GlobalModel.bbls using functions:     addnonlinearconstraints     addnonlinearor_compatible\n\nMandatory arguments are:     vars::Array{JuMP.VariableRef,1}\n\nOther arguments may be necessary for proper functioning:     For data-driven constraints, need:         X::DataFrame         Y:: Array     For constraint functions, need :         constraint::Union{JuMP.ConstraintRef, Expr}\n\nOptional arguments:     exprvars::Union{Array, Nothing}         JuMP variables as function arguments (i.e. vars rolled up into vector forms).         vars ⋐ flat(exprvars)     name::String     equality::Bool         Specifies whether function should be satisfied to an equality\n\n\n\n\n\n","category":"type"},{"location":"api/datastructures.html#Main.OCTHaGOn.BlackBoxRegressor","page":"Data structures","title":"Main.OCTHaGOn.BlackBoxRegressor","text":"@with_kw mutable struct BlackBoxRegressor\n\nAllows for approximation of constraints using OCTs. To be added to GlobalModel.bbls using functions:     addnonlinearconstraints     addnonlinearor_compatible\n\nMandatory arguments are:\n    vars::Array{JuMP.VariableRef,1}\n    dependent_var::JuMP.VariableRef\n\nOther arguments may be necessary for proper functioning:     For data-driven constraints, need:         X::DataFrame         Y:: Array     For constraint functions, need :         constraint::Union{JuMP.ConstraintRef, Expr}\n\nOptional arguments:     exprvars::Union{Array, Nothing}         JuMP variables as function arguments (i.e. vars rolled up into vector forms).         vars ⋐ flat(exprvars)     name::String     equality::Bool         Specifies whether function should be satisfied to an equality\n\n\n\n\n\n","category":"type"},{"location":"api/datastructures.html#Main.OCTHaGOn.LinkedLearner","page":"Data structures","title":"Main.OCTHaGOn.LinkedLearner","text":"Superclass of LinkedClassifier and LinkedRegressor.\n\n\n\n\n\n","category":"type"},{"location":"api/datastructures.html#Main.OCTHaGOn.LinkedClassifier","page":"Data structures","title":"Main.OCTHaGOn.LinkedClassifier","text":"Contains data for a constraint that is repeated. \n\n\n\n\n\n","category":"type"},{"location":"api/datastructures.html#Main.OCTHaGOn.LinkedRegressor","page":"Data structures","title":"Main.OCTHaGOn.LinkedRegressor","text":"Contains data for a constraint that is repeated. \n\n\n\n\n\n","category":"type"},{"location":"api/helpers.html#Helper-functions","page":"Helper functions","title":"Helper functions","text":"","category":"section"},{"location":"api/helpers.html","page":"Helper functions","title":"Helper functions","text":"Work in progress...","category":"page"},{"location":"api/helpers.html","page":"Helper functions","title":"Helper functions","text":"deconstruct\r\ndata_to_DataFrame\r\nget_datamap\r\nget_param\r\nget_varmap\r\nget_var_ranges\r\ngradientify\r\nfunctionify\r\nmerge_kwargs\r\nset_param\r\nsubstitute\r\nvars_from_expr","category":"page"},{"location":"api/helpers.html#Main.OCTHaGOn.deconstruct","page":"Helper functions","title":"Main.OCTHaGOn.deconstruct","text":"deconstruct(data::DataFrame, vars::Array, varmap::Array)\n\nTakes in data for input into a Function, and rips it apart into appropriate arrays.\n\n\n\n\n\n","category":"function"},{"location":"api/helpers.html#Main.OCTHaGOn.data_to_DataFrame","page":"Helper functions","title":"Main.OCTHaGOn.data_to_DataFrame","text":"data_to_DataFrame(data::Union{Dict, DataFrame, DataFrameRow})\n\nGets data with different keys, and returns a DataFrame with string headers.\n\n\n\n\n\n","category":"function"},{"location":"api/helpers.html#Main.OCTHaGOn.get_datamap","page":"Helper functions","title":"Main.OCTHaGOn.get_datamap","text":"Returns the mapping from flattened expr_vars to vars. \n\n\n\n\n\n","category":"function"},{"location":"api/helpers.html#Main.OCTHaGOn.get_param","page":"Helper functions","title":"Main.OCTHaGOn.get_param","text":"gets parameters within Dict. \n\n\n\n\n\n","category":"function"},{"location":"api/helpers.html#Main.OCTHaGOn.get_varmap","page":"Helper functions","title":"Main.OCTHaGOn.get_varmap","text":"get_varmap(expr_vars::Array, vars::Array)\n\nHelper function to map vars to flatvars. Arguments:     flatvars is a flattened Array{JuMP.VariableRef}     vars is the unflattened version, usually derived from an Expr. Returns:     Dict of ID maps\n\n\n\n\n\n","category":"function"},{"location":"api/helpers.html#Main.OCTHaGOn.get_var_ranges","page":"Helper functions","title":"Main.OCTHaGOn.get_var_ranges","text":"Returns the relevant index ranges for variables in expr_vars.\n\n\n\n\n\n","category":"function"},{"location":"api/helpers.html#Main.OCTHaGOn.gradientify","page":"Helper functions","title":"Main.OCTHaGOn.gradientify","text":"gradientify(expr::Expr, expr_vars::Array)\ngradientify(expr::JuMP.ConstraintRef, expr_vars::Array)\n\nTurns an expression into a gradient-able (via ForwardDiff), flattened function.  TODO: add option to not use gradients for certain functions or data driven constraints. \n\n\n\n\n\n","category":"function"},{"location":"api/helpers.html#Main.OCTHaGOn.functionify","page":"Helper functions","title":"Main.OCTHaGOn.functionify","text":"functionify(constraint::Any) -> Union{Nothing, Function}\n\n\nReturns an \"evaluate-able\" function from an Expr, or nothing for a JuMP.ConstraintRef. Can extend in the future to other elements.\n\n\n\n\n\n","category":"function"},{"location":"api/helpers.html#Main.OCTHaGOn.merge_kwargs","page":"Helper functions","title":"Main.OCTHaGOn.merge_kwargs","text":"Helper function for merging learner arguments. \n\n\n\n\n\n","category":"function"},{"location":"api/helpers.html#Main.OCTHaGOn.set_param","page":"Helper functions","title":"Main.OCTHaGOn.set_param","text":"Sets parameters within Dict. \n\n\n\n\n\n","category":"function"},{"location":"api/helpers.html#Main.OCTHaGOn.substitute","page":"Helper functions","title":"Main.OCTHaGOn.substitute","text":"For substitution into expressions. IMPORTANT. \n\n\n\n\n\n","category":"function"},{"location":"api/helpers.html#Main.OCTHaGOn.vars_from_expr","page":"Helper functions","title":"Main.OCTHaGOn.vars_from_expr","text":"vars_from_expr(expr::Expression, model::JuMP.Model)\n\nReturns the JuMP Variables that are associated with a given expression. Note: Expr's must be defined with a single input or a tuple of inputs, eg:\n\nex = :(x -> 5*x)\nex = :((x, y, z) -> sum(x[i] for i=1:4) - y[1] * y[2] + z)\n\n\n\n\n\n","category":"function"},{"location":"api/sampling.html#Sampling-methods","page":"Sampling methods","title":"Sampling methods","text":"","category":"section"},{"location":"api/sampling.html","page":"Sampling methods","title":"Sampling methods","text":"Work in progress...","category":"page"},{"location":"api/sampling.html","page":"Sampling methods","title":"Sampling methods","text":"uniform_sample_and_eval!\r\nlh_sample\r\nboundary_sample\r\nknn_sample","category":"page"},{"location":"api/sampling.html#Main.OCTHaGOn.uniform_sample_and_eval!","page":"Sampling methods","title":"Main.OCTHaGOn.uniform_sample_and_eval!","text":"uniform_sample_and_eval!(bbl::Union{BlackBoxLearner, GlobalModel, Array{BlackBoxLearner}};\n                          boundary_fraction::Float64 = 0.5,\n                          lh_iterations::Int64 = 0)\n\nUniform samples and evaluates a BlackBoxLearner. Furthermore, sets the big-M value.  Keyword arguments:     boundaryfraction: maximum ratio of boundary samples     lhiterations: number of GA populations for LHC sampling (0 is a random LH.)\n\n\n\n\n\n","category":"function"},{"location":"api/sampling.html#Main.OCTHaGOn.lh_sample","page":"Sampling methods","title":"Main.OCTHaGOn.lh_sample","text":"lh_sample(vars::Array{JuMP.VariableRef, 1}; lh_iterations::Int64 = 0,\n               n_samples::Int64 = 1000)\nlh_sample(bbl::BlackBoxLearner; lh_iterations::Int64 = 0,\n               n_samples::Int64 = 1000)\n\nUniformly Latin Hypercube samples the variables of GlobalModel, as long as all lbs and ubs are defined.\n\n\n\n\n\n","category":"function"},{"location":"api/sampling.html#Main.OCTHaGOn.boundary_sample","page":"Sampling methods","title":"Main.OCTHaGOn.boundary_sample","text":"boundary_sample(bbl::BlackBoxLearner; fraction::Float64 = 0.5)\nboundary_sample(vars::Array{JuMP.VariableRef, 1}; n_samples = 100, fraction::Float64 = 0.5,\n                     warn_string::String = \"\")\n\nSmartly samples the constraint along the variable boundaries.     NOTE: Because we are sampling symmetrically for lower and upper bounds,     the choose coefficient has to be less than ceil(half of number of dims).\n\n\n\n\n\n","category":"function"},{"location":"api/sampling.html#Main.OCTHaGOn.knn_sample","page":"Sampling methods","title":"Main.OCTHaGOn.knn_sample","text":"knn_sample(bbl::BlackBoxClassifier; k::Int64 = 10, sample_density = 1e-5, sample_idxs = nothing)\n\nDoes KNN and secant method based sampling once there is at least one feasible     sample to a BlackBoxLearner.\n\n\n\n\n\n","category":"function"},{"location":"basic.html#Basic-usage","page":"Basic usage","title":"Basic usage","text":"","category":"section"},{"location":"basic.html","page":"Basic usage","title":"Basic usage","text":"Work in progress...","category":"page"},{"location":"installation.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"As an overview of the installation steps, the current version of OCTHaGON works with Julia 1.5, with Interpretable AI as its back-end for constraint learning, and CPLEX as its default solver. Please follow the instructions below to get OCTHaGOn working on your machine. ","category":"page"},{"location":"installation.html#Installing-required-software","page":"Installation","title":"Installing required software","text":"","category":"section"},{"location":"installation.html#Julia","page":"Installation","title":"Julia","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Please find instructions for installing Julia on various platforms here. OCTHaGOn is compatible with Julia 1.5, but is frequently tested on Julia 1.5.4, making that the most robust version. However, if you have an existing Julia v1.5.4, we highly recommend you install a clean v1.5.x before proceeding. ","category":"page"},{"location":"installation.html#Interpretable-AI","page":"Installation","title":"Interpretable AI","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"OCTHaGOn requires an installation of Interpretable AI (IAI) for its various machine learning tools. Different builds of IAI are found here, corresponding to the version of Julia used. IAI requires a pre-built system image of Julia to replace the existing image (sys.so in Linux and sys.dll in Windows machines), thus the need for a clean install of Julia v1.5.x. For your chosen v1.5, please replace the system image with the one you downloaded. Then request and deploy an IAI license (free for academics) by following the instructions here. ","category":"page"},{"location":"installation.html#CPLEX","page":"Installation","title":"CPLEX","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"CPLEX is a mixed-integer optimizer that can be found here. It is free to solve optimization problems with up to 1000 variables and constraints, available via signing up, and also available via a free academic license for larger problems. ","category":"page"},{"location":"installation.html#Quickest-build","page":"Installation","title":"Quickest build","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Once the above steps are complete, we recommend using the following set of commands as the path of least resistance to getting started. ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Navigate to where you would like to put OCTHaGOn, and call the following commands to instantiate and check all of the dependencies. ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"git clone https://github.com/1ozturkbe/OCTHaGOn.jl.git\r\ncd OCTHaGOn.jl\r\njulia --project=.\r\nusing Pkg\r\nPkg.instantiate()","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Call the following to precompile all packages and load OCTHaGOn to your environment:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"include(\"src/OCTHaGOn.jl\")\r\nusing .OCTHaGOn","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Alternatively, you can test your installation of OCTHaGOn by doing the following in a new Julia terminal:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"using Pkg\r\nPkg.activate(\"test\")\r\nPkg.instantiate()\r\ninclude(\"test/load.jl\")\r\ninclude(\"test/src.jl\")","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Please see Basic usage for an simple application of OCTHaGOn to a MINLP!","category":"page"},{"location":"api/jump_utils.html#JuMP-and-MOI-utilities","page":"JuMP and MOI utilities","title":"JuMP and MOI utilities","text":"","category":"section"},{"location":"api/jump_utils.html","page":"JuMP and MOI utilities","title":"JuMP and MOI utilities","text":"These functions act on JuMP and MathOptInterface structures to be able to implement OCTHaGOn. ","category":"page"},{"location":"api/jump_utils.html","page":"JuMP and MOI utilities","title":"JuMP and MOI utilities","text":"bound!\r\nbounded_aux\r\nclassify_constraints\r\ndistance_to_set\r\nfetch_variable\r\nget_bounds\r\nget_constant\r\nget_unbounds\r\nlinearize_objective!\r\nrestrict_to_set\r\nvars_from_constraint","category":"page"},{"location":"api/jump_utils.html#Main.OCTHaGOn.bound!","page":"JuMP and MOI utilities","title":"Main.OCTHaGOn.bound!","text":"bound!(model::JuMP.Model, bound::Pair)\nbound!(model::JuMP.Model, bounds::Dict)\nbound!(model::GlobalModel, bounds::Union{Pair,Dict})\n\nAdds outer bounds to JuMP Model from Dict or Pair of data.\n\n\n\n\n\n","category":"function"},{"location":"api/jump_utils.html#Main.OCTHaGOn.bounded_aux","page":"JuMP and MOI utilities","title":"Main.OCTHaGOn.bounded_aux","text":"bounded_aux(x::Array{JuMP.VariableRef}, binary_var::JuMP.VariableRef)\nbounded_aux(x::Array{JuMP.VariableRef}, y::JuMP.VariableRef, binary_var::JuMP.VariableRef)\n\nGenerates binary-bounded auxiliary variables and their bounding constraints of the same size as x + y.\n\n\n\n\n\n","category":"function"},{"location":"api/jump_utils.html#Main.OCTHaGOn.classify_constraints","page":"JuMP and MOI utilities","title":"Main.OCTHaGOn.classify_constraints","text":"Separates and returns linear and nonlinear constraints in a model. \n\n\n\n\n\n","category":"function"},{"location":"api/jump_utils.html#Main.OCTHaGOn.distance_to_set","page":"JuMP and MOI utilities","title":"Main.OCTHaGOn.distance_to_set","text":"distance_to_set(val::Union{Array{<:Real},<:Real}, set::MOI.AbstractSet)\n\nWrapper around MathOptSetDistances.distancetoset. Distance 0 if val ∈ set. Otherwise, returns Float64.\n\n\n\n\n\n","category":"function"},{"location":"api/jump_utils.html#Main.OCTHaGOn.fetch_variable","page":"JuMP and MOI utilities","title":"Main.OCTHaGOn.fetch_variable","text":"fetch_variable(model::JuMP.Model, varkey::Union{Symbol, String, VariableRef, Array})\n\nReturns JuMP.VariableRefs that match a given Symbol, String, VariableRef, or array of these.\n\n\n\n\n\n","category":"function"},{"location":"api/jump_utils.html#Main.OCTHaGOn.get_bounds","page":"JuMP and MOI utilities","title":"Main.OCTHaGOn.get_bounds","text":"get_bounds(var::JuMP.VariableRef})\nget_bounds(vars::Array{JuMP.VariableRef})\n\nReturns bounds of JuMP variables.\n\n\n\n\n\nget_bounds(model::Union{Model, BlackBoxClassifier, BlackBoxRegressor, GlobalModel, Array{Union{BlackBoxClassifier, BlackBoxRegressor},N} where N}) -> Union{Pair{VariableRef,Array{Float64,1}}, Dict{_A,_B} where _B where _A}\n\n\nReturns bounds of all variables.\n\n\n\n\n\n","category":"function"},{"location":"api/jump_utils.html#Main.OCTHaGOn.get_constant","page":"JuMP and MOI utilities","title":"Main.OCTHaGOn.get_constant","text":"get_constant(set::MathOptInterface.AbstractSet) -> Any\n\n\nReturns constant of MOI.AbstractSet, if it exists. \n\n\n\n\n\n","category":"function"},{"location":"api/jump_utils.html#Main.OCTHaGOn.get_unbounds","page":"JuMP and MOI utilities","title":"Main.OCTHaGOn.get_unbounds","text":"get_unbounds(var::JuMP.VariableRef)\nget_unbounds(vars::Array{VariableRef})\nget_unbounds(gm::Union{JuMP.Model, GlobalModel})\n\nReturns variables with no lower and/or upper bounds.\n\n\n\n\n\nget_unbounds(model::Union{Model, BlackBoxClassifier, BlackBoxRegressor, GlobalModel, Array{Union{BlackBoxClassifier, BlackBoxRegressor},N} where N}) -> Union{Nothing, Dict{Any,Any}, Pair{VariableRef,Array{Float64,1}}}\n\n\nReturns only unbounded variables. \n\n\n\n\n\n","category":"function"},{"location":"api/jump_utils.html#Main.OCTHaGOn.linearize_objective!","page":"JuMP and MOI utilities","title":"Main.OCTHaGOn.linearize_objective!","text":"linearize_objective!(model::JuMP.Model)\n\nMakes sure that the objective function is affine.\n\n\n\n\n\n","category":"function"},{"location":"api/jump_utils.html#Main.OCTHaGOn.restrict_to_set","page":"JuMP and MOI utilities","title":"Main.OCTHaGOn.restrict_to_set","text":"restrict_to_set(var::JuMP.VariableRef, s::Union{Set, Array})\n\nRestricts variable to a set s. Useful for non-integer sets or when taking log of integer variables. \n\n\n\n\n\n","category":"function"},{"location":"api/jump_utils.html#Main.OCTHaGOn.vars_from_constraint","page":"JuMP and MOI utilities","title":"Main.OCTHaGOn.vars_from_constraint","text":"vars_from_constraint(con::JuMP.ConstraintRef)\n\nReturns the JuMP Variables that are associated with a JuMP.ConstraintRef.  Note: Currently only works for affine and quadratic constraints. \n\n\n\n\n\n","category":"function"},{"location":"api/jump_utils.html","page":"JuMP and MOI utilities","title":"JuMP and MOI utilities","text":"The following functions extend JuMP functions to act on OCTHaGOn's structs. ","category":"page"},{"location":"api/jump_utils.html","page":"JuMP and MOI utilities","title":"JuMP and MOI utilities","text":"all_variables\r\nset_optimizer","category":"page"},{"location":"api/jump_utils.html#JuMP.all_variables","page":"JuMP and MOI utilities","title":"JuMP.all_variables","text":"JuMP.all_variables(bbo::Union{GlobalModel, BlackBoxLearner})\nJuMP.all_variables(bbls::Array{BlackBoxLearner})\n\nExtends JuMP.all_variables to GlobalModels and BlackBoxLearners.  TODO: add ability to add variables to GlobalModels. \n\n\n\n\n\n","category":"function"},{"location":"api/jump_utils.html#JuMP.set_optimizer","page":"JuMP and MOI utilities","title":"JuMP.set_optimizer","text":"Extends JuMP.set_optimizer to GlobalModels. \n\n\n\n\n\n","category":"function"},{"location":"index.html#[OCTHaGOn](https://github.com/1ozturkbe/OCTHaGOn.jl)","page":"Home","title":"OCTHaGOn","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: codecov) (Image: )","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"OCTHaGOn (Optimal Classification Trees with Hyperplanes for Global Optimization) is a Julia package that allows for the solution of global optimization problems using mixed-integer (MI) linear and convex approximations. It is an implementation of the methods detailed in Chapter 2 of this thesis and submitted to Operations Research. OCTHaGOn is licensed under the MIT License. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"OCTHaGOn leans on the JuMP.jl  modeling language in its backend, and it develops MI approximations using  Interpretable AI, with a free academic license. The problems can then be solved by JuMP-compatible solvers, depending on  the type of approximation. OCT's default solver in tests is CPLEX,  which is free with an academic license as well. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This documentation is a work in progress.  If you have any burning questions or applications, or are having problems with OCTHaGOn, please create an issue! ","category":"page"},{"location":"api/mi_approximation.html#Mixed-integer-approximators","page":"Mixed-integer approximators","title":"Mixed-integer approximators","text":"","category":"section"},{"location":"api/mi_approximation.html","page":"Mixed-integer approximators","title":"Mixed-integer approximators","text":"These are the functions that help generate MI approximations of global optimization problems using the BlackBoxLearners. ","category":"page"},{"location":"api/mi_approximation.html","page":"Mixed-integer approximators","title":"Mixed-integer approximators","text":"Work in progress...","category":"page"},{"location":"api/mi_approximation.html","page":"Mixed-integer approximators","title":"Mixed-integer approximators","text":"add_feas_constraints!\r\nadd_regr_constraints!\r\nadd_tree_constraints!\r\nall_mi_constraints\r\nclear_data!\r\nclear_tree_constraints!\r\nclear_tree_data!\r\nupdate_tree_constraints!\r\nclear_lower_constraints!\r\nclear_upper_constraints!\r\nadd_relaxation_variables! \r\nclear_relaxation_variables!","category":"page"},{"location":"api/mi_approximation.html#Main.OCTHaGOn.add_feas_constraints!","page":"Mixed-integer approximators","title":"Main.OCTHaGOn.add_feas_constraints!","text":"Creates a set of binary feasibility constraints from a binary classification tree.  Arguments:\n\nm: JuMP Model\nx: independent JuMP.Variables (features in lnr)\nlnr: A fitted OptimalTreeClassifier\nequality: whether the constraint is an equality. \n\nNOTE: lcs, mic and lv are only nonempty if we are adding an OCT approximation of a BBR. Leave defaults empty for basic usage. \n\n\n\n\n\n","category":"function"},{"location":"api/mi_approximation.html#Main.OCTHaGOn.add_regr_constraints!","page":"Mixed-integer approximators","title":"Main.OCTHaGOn.add_regr_constraints!","text":"add_regr_constraints!(m::JuMP.Model, x::Array{JuMP.VariableRef}, y::JuMP.VariableRef, lnr::IAI.OptimalTreeClassifier, \n        ul_data::Dict; equality::Bool = false)\n\nCreates a set of MIO constraints from a OptimalTreeClassifier that thresholds a BlackBoxRegressor. Arguments:\n\nm:: JuMP Model\nx:: independent JuMP.Variable (features in lnr)\ny:: dependent JuMP.Variable (output of lnr)\nlnr:: A fitted OptimalTreeRegressor\nul_data:: Upper and lower bounding hyperplanes for data in leaves of lnr\n\n\n\n\n\n","category":"function"},{"location":"api/mi_approximation.html#Main.OCTHaGOn.add_tree_constraints!","page":"Mixed-integer approximators","title":"Main.OCTHaGOn.add_tree_constraints!","text":"add_tree_constraints!(gm::GlobalModel, bbl::BlackBoxLearner)\nadd_tree_constraints!(gm::GlobalModel, bbls::Vector{BlackBoxLearner})\nadd_tree_constraints!(gm::GlobalModel)\n\nGenerates MI constraints from gm.learners, and adds them to gm.model.\n\n\n\n\n\n","category":"function"},{"location":"api/mi_approximation.html#Main.OCTHaGOn.all_mi_constraints","page":"Mixed-integer approximators","title":"Main.OCTHaGOn.all_mi_constraints","text":"all_mi_constraints(bbl::BlackBoxLearner)\n\nReturns all JuMP.ConstraintRefs associated with BBL. \n\n\n\n\n\n","category":"function"},{"location":"api/mi_approximation.html#Main.OCTHaGOn.clear_data!","page":"Mixed-integer approximators","title":"Main.OCTHaGOn.clear_data!","text":"clear_data!(bbc::BlackBoxClassifier)\nclear_data!(bbr::BlackBoxRegressor)\n\nDeletes all data (NOT constraints) associated with object.  Please clear constraints using the cleartreeconstraints! function. \n\n\n\n\n\nClears all sampling, training and optimization data from GlobalModel. \n\n\n\n\n\n","category":"function"},{"location":"api/mi_approximation.html#Main.OCTHaGOn.clear_tree_constraints!","page":"Mixed-integer approximators","title":"Main.OCTHaGOn.clear_tree_constraints!","text":"clear_tree_constraints!(gm::GlobalModel, bbc::Union{BlackBoxClassifier, LinkedClassifier})\n\n\nClears the MI-approximating constraints and variables in GlobalModel and its sub-structs.\n\n\n\n\n\n","category":"function"},{"location":"api/mi_approximation.html#Main.OCTHaGOn.clear_tree_data!","page":"Mixed-integer approximators","title":"Main.OCTHaGOn.clear_tree_data!","text":"clear_tree_data!(bbc::BlackBoxClassifier)\nclear_tree_data!(bbr::BlackBoxRegressor)\n\nDeletes tree data associated with object. \n\n\n\n\n\n","category":"function"},{"location":"api/mi_approximation.html#Main.OCTHaGOn.update_tree_constraints!","page":"Mixed-integer approximators","title":"Main.OCTHaGOn.update_tree_constraints!","text":"update_tree_constraints!(gm::GlobalModel, bbr::BlackBoxRegressor, idx = length(bbr.learners))\nupdate_tree_constraints!(gm::GlobalModel, bbc::BlackBoxClassifier, idx = length(bbc.learners))\n\nUpdates the MI constraints associated with a BBL.  For BBRs, makes sure to replace the appropriate lower/upper/regressor approximations. \n\n\n\n\n\n","category":"function"},{"location":"api/mi_approximation.html#Main.OCTHaGOn.clear_lower_constraints!","page":"Mixed-integer approximators","title":"Main.OCTHaGOn.clear_lower_constraints!","text":"Clears lower-bounding constraints from a BBR and its associated GM. \n\n\n\n\n\n","category":"function"},{"location":"api/mi_approximation.html#Main.OCTHaGOn.clear_upper_constraints!","page":"Mixed-integer approximators","title":"Main.OCTHaGOn.clear_upper_constraints!","text":"Clears upper-bounding constraints from a BBR and its associated GM. \n\n\n\n\n\n","category":"function"},{"location":"api/mi_approximation.html#Main.OCTHaGOn.add_relaxation_variables!","page":"Mixed-integer approximators","title":"Main.OCTHaGOn.add_relaxation_variables!","text":"function add_relaxation_variables!(gm::GlobalModel, bbl::Union{BlackBoxLearner, LinkedLearner})\nfunction add_relaxation_variables!(gm::GlobalModel, bbls::Array)\n\nPopulates relax_var attributes of all substructs. \n\n\n\n\n\n","category":"function"},{"location":"api/mi_approximation.html#Main.OCTHaGOn.clear_relaxation_variables!","page":"Mixed-integer approximators","title":"Main.OCTHaGOn.clear_relaxation_variables!","text":"clear_relaxation_variables!(gm::GlobalModel, bbl::Union{BlackBoxClassifier, BlackBoxRegressor, LinkedClassifier, LinkedRegressor})\n\n\nClears slack variables in GlobalModel. \n\n\n\n\n\n","category":"function"},{"location":"api/constraints.html#Nonlinear-constraints","page":"Nonlinear constraints","title":"Nonlinear constraints","text":"","category":"section"},{"location":"api/constraints.html","page":"Nonlinear constraints","title":"Nonlinear constraints","text":"Work in progress...","category":"page"},{"location":"api/constraints.html","page":"Nonlinear constraints","title":"Nonlinear constraints","text":"add_nonlinear_constraint\r\nadd_nonlinear_or_compatible\r\nadd_linked_constraint","category":"page"},{"location":"api/constraints.html#Main.OCTHaGOn.add_nonlinear_constraint","page":"Nonlinear constraints","title":"Main.OCTHaGOn.add_nonlinear_constraint","text":"add_nonlinear_constraint(gm::GlobalModel,\n                 constraint::Union{JuMP.ConstraintRef, Expr};\n                 vars::Union{Nothing, Array{JuMP.VariableRef, 1}} = nothing,\n                 expr_vars::Union{Nothing, Array} = nothing,\n                 dependent_var::Union{Nothing, JuMP.VariableRef} = nothing,\n                 name::String = gm.name * \" \" * string(length(gm.bbls) + 1),\n                 equality::Bool = false)\n\nAdds a new nonlinear constraint to Global Model. Standard method for adding BlackBoxClassifiers and BlackBoxRegressors. \n\nNote: If adding constraints via an Expr, please define the appropriate vector indices. Eg.      expr = :((x) -> -x[1:$(N)]'*$(Q)*x[1:$(N)] - $(c)'*x[1:$(N)]), instead of      expr = :((x) -> -x'*$(Q)*x - $(c)'*x), to avoid vectorization errors.\n\n\n\n\n\n","category":"function"},{"location":"api/constraints.html#Main.OCTHaGOn.add_nonlinear_or_compatible","page":"Nonlinear constraints","title":"Main.OCTHaGOn.add_nonlinear_or_compatible","text":"function add_nonlinear_or_compatible(gm::GlobalModel,\n    constraint::Union{JuMP.ConstraintRef, Expr};\n    vars::Union{Nothing, Array{JuMP.VariableRef, 1}} = nothing,\n    expr_vars::Union{Nothing, Array} = nothing,\n    dependent_var::Union{Nothing, JuMP.VariableRef} = nothing,\n    name::String = gm.name * \"_\" * string(length(gm.bbls) + 1),\n    equality::Bool = false)\n\nExtends add_nonlinear_constraint to recognize JuMP compatible linear constraints and add them as linear JuMP constraints instead.\n\n\n\n\n\n","category":"function"},{"location":"api/constraints.html#Main.OCTHaGOn.add_linked_constraint","page":"Nonlinear constraints","title":"Main.OCTHaGOn.add_linked_constraint","text":"add_linked_constraint(gm::GlobalModel, bbc::BlackBoxClassifier, linked_vars::Array{JuMP.Variable})\nadd_linked_constraint(gm::GlobalModel, bbr::BlackBoxRegressor, linked_vars::Array{JuMP.Variable}, linked_dependent::JuMP.Variable)\n\nAdds a linked constraint of the same structure as the BBC/BBR.  When a nonlinear constraint is repeated more than once, this function allows the underlying approximator to be replicated without retraining trees for each constraint.   Note that the bounds used for sampling are for the original variables of the BBC/BBR, so be careful!\n\n\n\n\n\n","category":"function"},{"location":"api/constraints.html#Data-driven-constraints","page":"Nonlinear constraints","title":"Data driven constraints","text":"","category":"section"},{"location":"api/constraints.html","page":"Nonlinear constraints","title":"Nonlinear constraints","text":"add_variables_from_data!\r\nadd_datadriven_constraint\r\nbound_to_data!","category":"page"},{"location":"api/constraints.html#Main.OCTHaGOn.add_variables_from_data!","page":"Nonlinear constraints","title":"Main.OCTHaGOn.add_variables_from_data!","text":"add_variables_from_data!(gm::Union{JuMP.Model, GlobalModel},\n                        X::DataFrame)\n\nAdds/finds variables depending on the columns of X. \n\n\n\n\n\n","category":"function"},{"location":"api/constraints.html#Main.OCTHaGOn.add_datadriven_constraint","page":"Nonlinear constraints","title":"Main.OCTHaGOn.add_datadriven_constraint","text":"add_datadriven_constraint(gm::GlobalModel,\n                 X::DataFrame, Y::Array;\n                 constraint::Union{Nothing, JuMP.ConstraintRef, Expr} = nothing, \n                 vars::Union{Nothing, Array{JuMP.VariableRef, 1}} = nothing,\n                 dependent_var::Union{Nothing, JuMP.VariableRef} = nothing,\n                 name::String = \"bbl\" * string(length(gm.bbls) + 1),\n                 equality::Bool = false)\n\nAdds a data-driven constraint to GlobalModel. Data driven BBLs do not allow for resampling. \n\n\n\n\n\n","category":"function"},{"location":"api/constraints.html#Main.OCTHaGOn.bound_to_data!","page":"Nonlinear constraints","title":"Main.OCTHaGOn.bound_to_data!","text":"bound_to_data!(gm::Union{JuMP.Model, GlobalModel},\n              X::DataFrame)\n\nConstrains the domain of relevant variables to the box interval defined by X.\n\n\n\n\n\n","category":"function"}]
}
