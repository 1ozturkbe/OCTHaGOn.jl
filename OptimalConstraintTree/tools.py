import progressbar
from time import sleep
import sys, os
import io
import numpy as np

from gpkit import units
from gpfit.fit_constraintset import FitCS
from gpkit.nomials import SignomialInequality
from gpkit.keydict import KeyDict
from gpkit.small_scripts import mag
from gpkit import VectorVariable, Variable, Model
from gpkit.nomials import NomialArray, Nomial
from gpkitmodels.SP.SimPleAC.SimPleAC_mission import Mission, SimPleAC

text_trap = io.StringIO()

# Disable or enable printing for problematic functions
def blockPrint():
    """ Disables printing from this onward.
    Printing MUST BE REACTIVATED after. """
    sys.stdout = text_trap

def enablePrint():
    """ Enables print outputs.
    Counteracts blockPrint. """
    sys.stdout = sys.__stdout__

def clean_subs(subs):
    """
    Takes messy subs dicts and cleans it up.
    :param subs: Substitutions dictionary
    :return: Dict with proper uniting
    """
    cleaned_subs = {}
    vks = subs.keys()
    for vk in vks:
        try:
            cleaned_subs[vk] = subs[vk].value
        except:
            cleaned_subs[vk] = subs[vk]
    return cleaned_subs

def find_signomials(model):
    """
    Finds are returns all signomials in a GPkit model
    :param model:
    :return: signomial constraints
    """
    return [i for i in model.flat() if isinstance(i, SignomialInequality)]

def get_variables(constraints):
    """
    Finds all of the variables in the constraints
    :param constraints: GPkit constraints
    :return: GPkit variables
    """
    variables = set()
    for constraint in constraints:
        variables = variables.union(constraint.varkeys)
    return variables

def get_bounds(solutions, keys=None):
    """
    Finds the minimum and maximum of every variable
    from the solutions.
    :param model: GP model
    :param solutions: solutions to the GP model
    :return: bounds dict over varkeys
    """
    if not keys:
        keys = solutions[0].varnames(showvars=False, exclude=[])
    bounds = {}
    for _, varkey in keys.items():
        vals = [mag(sol['variables'][varkey]) for sol in solutions]
        if varkey.units:
            bounds[varkey] = [np.min(vals)*varkey.units,
                           np.max(vals)*varkey.units]
        else:
            bounds[varkey] = [np.min(vals), np.max(vals)]
    return bounds

def constraints_from_bounds(bounds, gpinput):
    """
    Generates trust region constraints from bounds
    :param bounds: set/subset of bounds generated by get_bounds
    :param gpinput: GPkit Vector/Variables of same size as bounded vars,
                    or a GPkit model
    :return: list of PosynomialInequalities
    """
    if isinstance(gpinput, Model):
        varkeys = KeyDict({varkey: gpinput[varkey.name] for varkey in bounds.keys()})
    else:
        raise ValueError("Other types of inputs currently not supported.")
    # elif isinstance(gpinput, NomialArray):
    #     varkeys = KeyDict({key})
    # elif isinstance(gpinput, list):
    #     varkeys = KeySet(bounds.keys())
    constraints = []
    for key, value in bounds.items():
        # Non-vector variables
        if isinstance(value[0], Nomial):
            value = [v.value for v in value]
        try:
            constraints.extend([gpinput[key.name] <= max(value),
                                gpinput[key.name] >= min(value)])
        except KeyError:
            constraints.extend([gpinput.variables_byname(key.name) <= max(value),
                                gpinput.variables_byname(key.name) >= min(value)])
    for constr in constraints:
        constr.bound = True
    if len(constraints) != 2*len(bounds):
        raise ValueError("Number of bounding constraints does"
                         "not match the number of specified bounds.")
    return constraints


def constraint_from_gpfit(fitcs, dvar, ivars, basis=None):
    """
    Returns a posynomial constraint from a data fit
    :param fitcs: FitCS object
    :param dvar: dependent variable
    :param ivars: independent variables
    :return: constraint
    """
    basis_keys = list(basis.keys())
    ivar_keys = [ivar.key for ivar in ivars]
    try:
        nondim_dvar = dvar/basis[dvar.key]
    except KeyError:
        raise KeyError("Independent variable %s "
                       "is not in the basis to be "
                       "normalized" % dvar.key)
    basis.pop(dvar.key)
    try:
        nondim_ivars = [ivars[i]/basis[basis_keys[i]] for i in range(len(basis.keys()))]
    except KeyError:
        raise KeyError("There is a dependent variable "
                       "missing in the basis, or there is an "
                       "incorrect type. ")
    new_fitcs = FitCS(fitcs.fitdata, nondim_dvar, nondim_ivars)
    return new_fitcs

def mergeDict(dict1, dict2):
    """ Merge dictionaries and keep values of common keys in list. """
    dict3 = {**dict1, **dict2}
    for key, value in dict3.items():
        if key in dict1 and key in dict2:
            dict3[key] = value + dict1[key]
    return dict3

def check_units(thing):
    """
    :param thing: Monomial or a collection of Monomials
    :return:
    """
    if isinstance(thing, Nomial):
        if thing.units:
            raise ValueError('Monomial %s has units %s but '
                             'is required to be unitless. '
                             % (thing, thing.units))
    if isinstance(set, list):
        for one_thing in thing:
            if one_thing.units:
                raise ValueError('Monomial %s has units %s but '
                     'is required to be unitless. '
                     % (one_thing, one_thing.units))

def prep_SimPleAC():
    """ A useful model for tests. """
    m = Mission(SimPleAC(), 4)
    m.cost = m['W_{f_m}'] * units('1/N') + m['C_m'] * m['t_m']
    basis = {
        m['h_{cruise_m}'].key: 5000 * units('m'),
        m['Range_m'].key: 3000 * units('km'),
        m['W_{p_m}'].key: 6250 * units('N'),
        m['\\rho_{p_m}'].key: 1500 * units('kg/m^3'),
        m['C_m'].key: 120 * units('1/hr'),
        m['V_{min_m}'].key: 25 * units('m/s'),
        m['T/O factor_m'].key: 2,
    }
    m.substitutions.update(basis)
    return m, basis